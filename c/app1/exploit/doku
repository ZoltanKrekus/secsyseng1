Um welche Art von Schwachstelle handelt es sich? (kurzer theoretischer Hintergrund)
Broken Authentication and Session Management
Die SessionIds mit denen sich User authentifizieren können werden nicht ausreichend geschützt.
In unserem Fall gibt es gleich mehrere Probleme:
- SessionId kann berechnet werden, da diese einfach inkrementiert wird
- Es gibt keine Timeouts für SessionIds
- Die SessionId steht unverschlüsselt im Hauptspeicher (die WebApp kommt der Einfachheit halber ohne DB aus und speichert alles In-Memory)
Anmerkung: Beim Fix beschränken wir uns auf die Erstellung der SessionIds, diese also unberechenbar zu machen, Timeout-Handling und Verschlüsselung wurden der Einfachheit halber ausgelassen, da wir uns nur auf die SessionId Erstellung fokkusieren möchten.


Genaue Angabe wo sich der Fehler befindet (z.b. Codezeilen, etc.)
Im Prinzip wird bei der Erstellung von neuen SessionIds nur ein Counter hochgezählt.
Einzige "Schutzmaßnahme" die von haus aus getroffen wurde war einen AtomicLong zu verwenden um Concurrency Probleme zu vermeiden, doch diese Maßnahme reicht nicht aus um sichere IDs zu generieren.

service.UserManager, Line 21: 
	private final static AtomicLong SESSION_COUNTER = new AtomicLong();
Hier wird ein AtomicLong instanziert welches zur Vergabe der SessionIds verwendet wird

service.UserManager, Line 50:
	long sessionId = UserManager.SESSION_COUNTER.incrementAndGet();
Bei jedem neuen Login per username/password Kombination wird einfach per Inkrement eine neue ID vergeben.
Dies ist zu wenig und resultiert in vorhersagbaren Session IDs
Ein Angreifer kann sich z.b. mit seinem legitimen Account einloggen um zu sehen wie hoch der Counter gerade ist.
Anschließend muss er bei zukünftigen Logins anderer User nur noch mittels Skript o.ä eine Range von Session Ids von <aktuelle ID zum Login Zeitpunkt des Angreifers> bis <Long.MaxValue> ausprobieren.
Noch einfacher, aber langsamer, wäre die Range <1> bis <Long.MaxValue>

Beschreibung wie der Fehler behoben werden kann (falls verschiedene Möglichkeiten existieren, um diese Schwachstelle zu beheben, führen Sie mehrere an).
Unser Fix bestand UUID zu verwenden.
Dabei handelt es sich um 128-bit lange "Universally Unique Identifier".
UUIDs sind zwar pseudo-random, aber sehr stark, eine Vorhersage bzw Erraten ist in der Praxis demnach kein realer Angriffsvektor.
Es gäbe natürlich noch weitere Möglichkeiten den Fehler zu beheben, wie die von JSF zur Verfügung gestellten APIs für Session Cookies, da diese Implementierung ohnehin besser ist als alles selbst geschriebene.
Um die notwenigen Änderungen am Code möglichst gering zu halten (aber natürlich trotzdem ausreichend Sicherheit zu bieten) entschlossen wir uns für UUIDs, da dieser Fix für unseren Fall durchaus ausreichend ist.
Desweiteren sollte man in einer realen Anwendung natürlich auch Session Timeouts einführen, sowie die SessionIds verschlüsselt in der Persistenz ablegen.

Aktueller Fall
Im Jahr 2012 war Blizzard von Session Hijacking Angriffen betroffen was damals sehr große Wellen schlug, da potentiell Millionen von Online-Spielern betroffen waren
http://www.tomshardware.com/news/Diablo-3-Authenticator-Battle.net-Bashiok-Password,15724.html
Etwas aktueller: Heartbleed, die wahrscheinlich größte Sicherheitslücke des Internets aller Zeiten - auch hier ist Session Hijacking möglich.
Bei der Heartbleed Attacke ist es möglich einem anfälligen Server manipulierte Anfragen zu senden, woraufhin der Server dem Client mehr sendet als dieser eigentlich sehen dürfte.
Genauer gesagt führt eine falsche Längenüberprüfung dazu das der Angreifer bis zu 64KByte aus dem Hauptspeicher des Servers auslesen kann.
Somit kann es auch möglich sein das sich in diesen 64k SessionIds bzw. -fragmente befinden wodurch Session Hijacking möglich wird - gesetz dem Fall, dass der Server die SessionIds (wie in unserem Beispiel) unverschlüsselt im Hauptspeicher hat.
https://www.mattslifebytes.com/?p=533
https://de.wikipedia.org/wiki/Heartbleed

